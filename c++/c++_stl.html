<!DOCTYPE html>
    <html>
    <head>
        <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-alpha/dist/katex.min.css" integrity="sha384-BTL0nVi8DnMrNdMQZG1Ww6yasK9ZGnUxL1ZWukXQ7fygA1py52yPp9W4wrR00VML" crossorigin="anonymous">
        <style>
/*--------------------------------------------------------------------------------------------- * Copyright (c) Microsoft Corporation. All rights reserved. * Licensed under the MIT License. See License.txt in the project root for license information. *--------------------------------------------------------------------------------------------*/ body { font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback"; font-size: 14px; padding: 0 26px; line-height: 22px; word-wrap: break-word; } #code-csp-warning { position: fixed; top: 0; right: 0; color: white; margin: 16px; text-align: center; font-size: 12px; font-family: sans-serif; background-color:#444444; cursor: pointer; padding: 6px; box-shadow: 1px 1px 1px rgba(0,0,0,.25); } #code-csp-warning:hover { text-decoration: none; background-color:#007acc; box-shadow: 2px 2px 2px rgba(0,0,0,.25); } body.scrollBeyondLastLine { margin-bottom: calc(100vh - 22px); } body.showEditorSelection .code-line { position: relative; } body.showEditorSelection .code-active-line:before, body.showEditorSelection .code-line:hover:before { content: ""; display: block; position: absolute; top: 0; left: -12px; height: 100%; } body.showEditorSelection li.code-active-line:before, body.showEditorSelection li.code-line:hover:before { left: -30px; } .vscode-light.showEditorSelection .code-active-line:before { border-left: 3px solid rgba(0, 0, 0, 0.15); } .vscode-light.showEditorSelection .code-line:hover:before { border-left: 3px solid rgba(0, 0, 0, 0.40); } .vscode-light.showEditorSelection .code-line .code-line:hover:before { border-left: none; } .vscode-dark.showEditorSelection .code-active-line:before { border-left: 3px solid rgba(255, 255, 255, 0.4); } .vscode-dark.showEditorSelection .code-line:hover:before { border-left: 3px solid rgba(255, 255, 255, 0.60); } .vscode-dark.showEditorSelection .code-line .code-line:hover:before { border-left: none; } .vscode-high-contrast.showEditorSelection .code-active-line:before { border-left: 3px solid rgba(255, 160, 0, 0.7); } .vscode-high-contrast.showEditorSelection .code-line:hover:before { border-left: 3px solid rgba(255, 160, 0, 1); } .vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before { border-left: none; } img { max-width: 100%; max-height: 100%; } a { text-decoration: none; } a:hover { text-decoration: underline; } a:focus, input:focus, select:focus, textarea:focus { outline: 1px solid -webkit-focus-ring-color; outline-offset: -1px; } hr { border: 0; height: 2px; border-bottom: 2px solid; } h1 { padding-bottom: 0.3em; line-height: 1.2; border-bottom-width: 1px; border-bottom-style: solid; } h1, h2, h3 { font-weight: normal; } h1 code, h2 code, h3 code, h4 code, h5 code, h6 code { font-size: inherit; line-height: auto; } table { border-collapse: collapse; } table > thead > tr > th { text-align: left; border-bottom: 1px solid; } table > thead > tr > th, table > thead > tr > td, table > tbody > tr > th, table > tbody > tr > td { padding: 5px 10px; } table > tbody > tr + tr > td { border-top: 1px solid; } blockquote { margin: 0 7px 0 5px; padding: 0 16px 0 10px; border-left-width: 5px; border-left-style: solid; } code { font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback"; font-size: 14px; line-height: 19px; } body.wordWrap pre { white-space: pre-wrap; } .mac code { font-size: 12px; line-height: 18px; } pre:not(.hljs), pre.hljs code > div { padding: 16px; border-radius: 3px; overflow: auto; } /** Theming */ pre code { color: var(--vscode-editor-foreground); } .vscode-light pre:not(.hljs), .vscode-light code > div { background-color: rgba(220, 220, 220, 0.4); } .vscode-dark pre:not(.hljs), .vscode-dark code > div { background-color: rgba(10, 10, 10, 0.4); } .vscode-high-contrast pre:not(.hljs), .vscode-high-contrast code > div { background-color: rgb(0, 0, 0); } .vscode-high-contrast h1 { border-color: rgb(0, 0, 0); } .vscode-light table > thead > tr > th { border-color: rgba(0, 0, 0, 0.69); } .vscode-dark table > thead > tr > th { border-color: rgba(255, 255, 255, 0.69); } .vscode-light h1, .vscode-light hr, .vscode-light table > tbody > tr + tr > td { border-color: rgba(0, 0, 0, 0.18); } .vscode-dark h1, .vscode-dark hr, .vscode-dark table > tbody > tr + tr > td { border-color: rgba(255, 255, 255, 0.18); } 
</style>
<style>
/* Tomorrow Theme */ /* http://jmblog.github.com/color-themes-for-google-code-highlightjs */ /* Original theme - https://github.com/chriskempson/tomorrow-theme */ /* Tomorrow Comment */ .hljs-comment, .hljs-quote { color: #8e908c; } /* Tomorrow Red */ .hljs-variable, .hljs-template-variable, .hljs-tag, .hljs-name, .hljs-selector-id, .hljs-selector-class, .hljs-regexp, .hljs-deletion { color: #c82829; } /* Tomorrow Orange */ .hljs-number, .hljs-built_in, .hljs-builtin-name, .hljs-literal, .hljs-type, .hljs-params, .hljs-meta, .hljs-link { color: #f5871f; } /* Tomorrow Yellow */ .hljs-attribute { color: #eab700; } /* Tomorrow Green */ .hljs-string, .hljs-symbol, .hljs-bullet, .hljs-addition { color: #718c00; } /* Tomorrow Blue */ .hljs-title, .hljs-section { color: #4271ae; } /* Tomorrow Purple */ .hljs-keyword, .hljs-selector-tag { color: #8959a8; } .hljs { display: block; overflow-x: auto; color: #4d4d4c; padding: 0.5em; } .hljs-emphasis { font-style: italic; } .hljs-strong { font-weight: bold; }
</style>
<style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'HelveticaNeue-Light', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
    </head>
    <body>
        <h1 id="deep-insight-of-c-stl">deep insight of c++ stl</h1>
<p>Reference:</p>
<ul>
<li>侯捷《STL源码解析》</li>
</ul>
<p>核心组件：container，algorithm, iterator, allocator, functor, adapter</p>
<h2 id="1%E6%BA%90%E7%A0%81%EF%BC%9A%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE%E5%99%A8allocator">1.源码：资源配置器Allocator</h2>
<p>（1）设计：<font color=red>向system heap申请空间，考虑多线程，考虑内存不足的措施，考虑过多小型区块造成内存破碎问题。</font>
（2）std规格的allocators定义在defallocator.h，只是对::operator new和::operator delete的简单包装，并未考虑分配效率，分配失败等情况。在sgi_stl中使用stl_alloc.h,实现二级分配策略。
（3）当申请大于128B时，执行一级分配，直接使用c的malloc和free。有历史原因，而且c++没有remalloc操作。
（4）当申请小于128时，利用内存池进行分配回收，实行8字节对齐,维护16个linklist。<font color=red><strong>利用union实现链表节点结构，可以避免额外的管理空间。</strong></font>当内存不足时，执行一级策略向系统申请，由于一级使用c语言，所以用c语言模拟c++的new handle机制。stl标准的配置器定义在memory中。</p>
<h2 id="2%E6%BA%90%E7%A0%81%EF%BC%9A%E8%BF%AD%E4%BB%A3%E5%99%A8iterator">2.源码：迭代器Iterator</h2>
<p>(1)iterator is a smart pointer, the most common actions of pointer are defeference and memeber access. so the most important design of iterator is overloading of operator * and operator -&gt;.
Inreference to auto_ptr, a wrapper of native pointer to deal with the memory leak problem.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">class</span> <span class="hljs-title">auto_ptr</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">auto_ptr</span><span class="hljs-params">(T *p = <span class="hljs-number">0</span>)</span> : <span class="hljs-title">pointee</span><span class="hljs-params">(p)</span> </span>{};
    <span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">U</span>&gt;
    <span class="hljs-title">auto_ptr</span>(<span class="hljs-title">auto_ptr</span>&lt;U&gt;&amp; <span class="hljs-title">rhs</span>) :</span> pointee(rhs.release());
    ~ autp_ptr() {};

    <span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">U</span>&gt;
    <span class="hljs-title">auto_ptr</span>&lt;T&gt;&amp; <span class="hljs-title">operator</span>=(<span class="hljs-title">auto_ptr</span>&lt;U&gt;&amp; <span class="hljs-title">rhs</span>) {</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;rhs) reset(rhs.release());
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    T&amp; <span class="hljs-keyword">operator</span>*() {<span class="hljs-keyword">return</span> *pointee};
    T* <span class="hljs-keyword">operator</span>-&gt;() {<span class="hljs-keyword">return</span> pointee};
    <span class="hljs-function">T* <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>{<span class="hljs-keyword">return</span> pointee};
    <span class="hljs-comment">//...</span>

<span class="hljs-keyword">private</span>:
    T *pointee;
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">item</span>&gt;
<span class="hljs-title">struct</span> <span class="hljs-title">Iterator</span> {</span>
    item* ptr;
    Iterator(item* p = <span class="hljs-number">0</span>) : ptr(p) {};

    item&amp; <span class="hljs-keyword">operator</span>*() <span class="hljs-keyword">const</span> {<span class="hljs-keyword">return</span> *ptr};
    item* <span class="hljs-keyword">operator</span>-&gt;() <span class="hljs-keyword">const</span> {<span class="hljs-keyword">return</span> ptr};

<span class="hljs-comment">//以下两个operator++遵循标准作法</span>
    Iterator&lt;item&gt;&amp; <span class="hljs-keyword">operator</span>++() {  <span class="hljs-comment">//pre-increment,item要不要写？</span>
        ptr = pte-&gt;next(); <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
    Iterator&lt;item&gt; <span class="hljs-keyword">operator</span>++(<span class="hljs-keyword">int</span>) {  <span class="hljs-comment">//post-increment</span>
        Iterator tmp = *<span class="hljs-keyword">this</span>; ++*<span class="hljs-keyword">this</span>; <span class="hljs-keyword">return</span> tmp;
    }

    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> Iterator&amp; i) <span class="hljs-keyword">const</span> {<span class="hljs-keyword">return</span> ptr==i.ptr;}
    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> Iterator&amp; i) <span class="hljs-keyword">const</span> (<span class="hljs-keyword">return</span> ptr!=i.ptr;)
}
</div></code></pre>
<p>（2）traits编程技法：类型萃取</p>
<ul>
<li>利用function template 的自变量推导机制。</li>
<li>加上原生类型和const的偏特化。</li>
<li>注意typeid的使用。</li>
<li>迭代器最常用的五种型别(嵌套的)：value_type , difference_type , pointer , reference , iterator_categor</li>
<li>五种迭代器(继承，重载)：input Interator, output Iterator, Forward Interator, Bidirectionnal, RandomAccess</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">struct</span> <span class="hljs-title">iterator_traits</span> {</span>
    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">typename</span> T::value_type value_type;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">struct</span> <span class="hljs-title">iterator_traits</span>&lt;T*&gt; {</span>
    <span class="hljs-keyword">typedef</span> T value_type;
}

<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;
<span class="hljs-title">struct</span> <span class="hljs-title">iterator_traits</span>&lt;const T*&gt; {</span>
    <span class="hljs-keyword">typedef</span> T value_type;
}
</div></code></pre>
<pre class="hljs"><code><div><span class="hljs-comment">//stl提供了iterator class作为迭代器的父类</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Category</span>,
          <span class="hljs-title">class</span> <span class="hljs-title">T</span>,
          <span class="hljs-title">class</span> <span class="hljs-title">Distance</span> = <span class="hljs-title">ptrdiff_t</span>,
          <span class="hljs-title">class</span> <span class="hljs-title">Pointer</span> = <span class="hljs-title">T</span> *,
          <span class="hljs-title">class</span> <span class="hljs-title">Reference</span> = <span class="hljs-title">T</span>&amp;,&gt;
<span class="hljs-title">struct</span> <span class="hljs-title">iterator</span> {</span>
    <span class="hljs-keyword">typedef</span> Category iterator_catogary;
    <span class="hljs-keyword">typedef</span> T value_type;
    <span class="hljs-keyword">typedef</span> Distance defference_type;
    <span class="hljs-keyword">typedef</span> Pointer pointer;
    <span class="hljs-keyword">typedef</span> Reference reference;
}
</div></code></pre>
<blockquote>
<p>traits编程技法，大量运用于STL中。它运用nest type的编码技巧和编译器的template自变量推导功能，补强c++未能提供的关于类型的认证功能，补强c++不为strong type的遗憾。</p>
</blockquote>
<h2 id="3%E6%BA%90%E7%A0%81%EF%BC%9A%E5%BA%8F%E5%88%97%E5%AE%B9%E5%99%A8sequence-containers">3.源码：序列容器Sequence Containers</h2>
<p><img src="file:///home/mrk/Documents/rsc/stlContainer.png" alt="stl容器"></p>
<h3 id="1vector">(1)vector</h3>
<h3 id="2list">(2)list</h3>
<h3 id="3deque">(3)deque</h3>
<h3 id="4stack">(4)stack</h3>
<h3 id="5queue">(5)queue</h3>
<h3 id="6priorityqueue">(6)priority_queue</h3>
<h3 id="%E6%80%9D%E8%80%83">思考</h3>
<p>1)vector和list分别在什么情况下使用？<br>
2)为什么set和map的实现使用RB-tree？RB-tree对于AVL-tree的优势在哪？
<a href="https://blog.csdn.net/mmshixing/article/details/51692892">https://blog.csdn.net/mmshixing/article/details/51692892</a></p>
<h2 id="4%E6%BA%90%E7%A0%81%EF%BC%9A%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8associative-containers">4.源码：关联式容器Associative Containers</h2>
<blockquote>
<p>unordered_map的底层是hashtable, 所有与顺序无关；map的底层是红黑树，所以map的效率取决于红黑树的效率。</p>
</blockquote>
<h3 id="1rbtree">(1)RB_tree</h3>
<h3 id="2set">(2)set</h3>
<h3 id="3map">(3)map</h3>
<h3 id="4multiset">(4)multiset</h3>
<h3 id="5multimap">(5)multimap</h3>
<h2 id="5%E6%BA%90%E7%A0%81%EF%BC%9A%E7%AE%97%E6%B3%95algorithm">5.源码：算法Algorithm</h2>
<h2 id="6%E6%BA%90%E7%A0%81%EF%BC%9A%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1function-class">6.源码：函数对象Function Class</h2>
<pre><code>仿函数的作用主要在哪？STL所提供的各种算法，往往有两个版本，其中一个版本是最常用的某种运算，第二个版本表现为泛化的过程，允许用户“以template参数来指定所要采用的策略“。如果要将”操作“作为算法的参数，唯一的方法是将该”操作“设计为一个函数，再将函数的指针当作算法的一个参数;或者就该”操作“设计为一个所谓的函数对象，并将该对象作为算法的一个参数。
那么为什么不使用函数指针呢？原因在于函数指针不能满足STL对于抽象性的要求，也不能满足软件的要求（函数指针无法和STL其他组件搭配，产生更灵活的变化）。
函数对象必须自定义function call运算符(operator()),拥有这样的运算符后，我们就可以在仿函数的对象后面加上一对小括号，以此调用函数对象定义的operator()。
若以操作数的个数分，可分为一元和二元，若以功能分，可分为Arithmetic, Rational, Logical。头文件&lt;functional&gt;。
一般而言，不会有人单独运用这些功能机器简单的函数对象，主要用途是搭配STL算法。
</code></pre>
<h3 id="unaryfunction">unary_function</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Arg</span>, <span class="hljs-title">class</span> <span class="hljs-title">Result</span>&gt;
<span class="hljs-title">struct</span> <span class="hljs-title">unary_function</span> {</span>
    <span class="hljs-keyword">typedef</span> Arg argument_type;
    <span class="hljs-keyword">typedef</span> Result result_type;
}
</div></code></pre>
<h3 id="binaryfunction">binary_function</h3>
<h3 id="6%E4%B8%AA%E7%AE%97%E6%9C%AF%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1">6个算术函数对象</h3>
<ul>
<li>plus&lt;T&gt;</li>
<li>minus&lt;T&gt;</li>
<li>multiplies&lt;T&gt;</li>
<li>divides&lt;T&gt;</li>
<li>modulus&lt;T&gt;</li>
<li>negation&lt;T&gt;</li>
</ul>
<h3 id="6%E4%B8%AA%E8%BF%90%E7%AE%97%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1">6个运算函数对象</h3>
<ul>
<li>equal_to&lt;T&gt;</li>
<li>not_equal_to&lt;T&gt;</li>
<li>greater&lt;T&gt;</li>
<li>greater_equal&lt;T&gt;</li>
<li>less&lt;T&gt;</li>
<li>less_equal&lt;T&gt;</li>
</ul>
<h3 id="3%E4%B8%AA%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1">3个逻辑运算函数对象</h3>
<ul>
<li>logical_and&lt;T&gt;</li>
<li>logical_or&lt;T&gt;</li>
<li>logical_not&lt;T&gt;</li>
</ul>
<h2 id="7%E6%BA%90%E7%A0%81%EF%BC%9A%E9%85%8D%E6%8E%A5%E5%99%A8adapter">7.源码：配接器Adapter</h2>
<h3 id="container-adapters">container adapters</h3>
<ul>
<li>queue</li>
<li>stack</li>
<li>priority_queue</li>
</ul>
<h3 id="iterator-adapters">iterator adapters</h3>
<ul>
<li>insert iterators(底层为容器)</li>
<li>reverse iterators(底层为iterator)</li>
<li>iostream iterators(底层为iostream)</li>
</ul>
<p>注：所谓迭代器配接器很少以迭代器为直接对象，所谓对迭代器的修饰只是一种观念上的改变。</p>
<h3 id="function-adapters%E8%B6%85%E7%81%B5%E6%B4%BB%EF%BC%8C%E6%95%B0%E9%87%8F%E6%9C%80%E5%BA%9E%E5%A4%A7">function adapters(超灵活，数量最庞大)</h3>
<pre><code>function adapters的价值在于，通过他们之间的绑定，组合，修饰能力，几乎可以无限制地创造出各种表达式，搭配STL算法一起使用。
function adapters提供了一系列辅助函数。STL提供了众多的配接器，使”一般函数“和”成员函数“得以无缝地与其他配接器和算法结合起来。
所有期望获得配接能力的组件，本身必须是可配接的。换句话说，一元仿函数必须继承自unary_function, 二元仿函数必须继承自binary_function, 成员函数必须经过mem_fun处理过，一般函数必须经过ptr_fun处理过。
</code></pre>
<ul>
<li>bind1st(const Op&amp; op, const T&amp; x), bind2nd();</li>
<li>not1(const Pred&amp; pred), not2();</li>
<li>ptr_fun(Result(*fp)(Arg)), ptr_fun(Result(*fp)(Arg1, Arg2));</li>
<li>mem_fun(S (T::*f)()), mem_fun(S (T::*f)() const), mem_fun_ref(S (T::*f)()), mem_fun_ref(S (T::*f)() const) 二元的重载了。</li>
</ul>

    </body>
    </html>