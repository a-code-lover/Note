# notes

## 第二章：变量与类型

###　类型系统

> + 一般float和double分别是7，16个有效位。  
> + 类型char实际上会表现为signed char还是unsigned char，由编译器决定。  
> + c++的设计原则之一是尽可能接近硬件。。。  
> + 避免无法预知和依赖于实现环境的行为。
> + 运算符运算之前会先将运算参数转换为同样的类型。
> + 指定字面值的类型。
> + 对象是具有某种数据类型的内存空间。
> + constexpr变量？？？

[类型选择](../rsc/类型选择.png)  
[不同类型系统的语言](https://www.zhihu.com/question/19918532)  
[常用语言的类型系统分类](../rsc/类型.png)  
[不同类型系统的可移植问题](https://blog.csdn.net/u014659656/article/details/46779381)  
[c++类型转换](https://blog.csdn.net/zdplife/article/details/50922456)  
[c++类型转换](https://segmentfault.com/a/1190000016582440)  

###　类型占用内存

[int占几个字节？](https://blog.csdn.net/u014492609/article/details/38067599)  
[CPU与操作系统约束](https://blog.csdn.net/championhengyi/article/details/80458060)  
[vs为什么没有64位版本](https://www.zhihu.com/question/20370633)  
[数据模型](https://www.cnblogs.com/lsgxeva/p/7614856.html)

###　变量

1.默认初始化
(1)**内置类型**如果在函数体外,默认初始化为0; 如果**在函数体内,则不被初始化**,（严格来说，编译器并未被要求检查此类错误，大多数编译器会对部分使用未初始化变量的行为给出警告，使用未初始化的变量会带来不可预估的结果）。
(2)每个类各自决定其初始化的方式。
(3)连续赋值：赋值号是从右到左的，（赋值返回引用？？），(x=y)=3。

2.列表初始化

3.声明和定义
c++支持分离式编译，允许将一个程序拆分为多个文件分别单独编译，为了支持分离编译，c++将声明和定义区别。声明使得名字为程序所知，一个文件如何想使用别处定义的名字，就必须包含对这个名字的声明。而定义负责创建与名字关联的实体。`extern int i;//声明i而非定义i`，`int j;//声明并定义j`，`external dooble pi = 3.14;//定义`。可以多次声明，只能一次定义。

### 复合类型（指针和引用）

类型修饰符（*&）不过是**声明符**的一部分罢了，而非基本类型的一部分。**基本类型+类型修饰符+变量名**
引用必须初始化，无法重新绑定到新的对象。
使用未初始化的指针会引起的运行错误，`void*`能做的比较有限：和别的指针比较，作为函数的输入输出(**制作模板**)，或者赋值给另一个void指针。

### const

```c++
  int i = 0;
  int *const p1 = &i;  //顶层const, 不能修改p1
  const int ci = 42;  //顶层const，不能修改ci
  const int *p2 = &ci;  //底层const，允许修改p2
  const int *const p3 = p2;
  const int &r = ci;  //用于声明引用的const都是底层const
```

### 类型处理

1.通过`typedef`或`using =`进行别名声明，使得复杂的类型名称简单化。
2.auto类型声明符能让编辑器替我们分析表达式的类型，但推断出来的类型和初始值类型并不完全相同，auto会忽略顶层的const，留下底层的const；也可能去掉引用。。。
3.decltype类型指示符，作用是选择并返回操作数的数据类型，编译器分析表达式并得到类型，但**不会执行表达式或函数**。
如果表达式是**解引用**或者**有双层括号**，则结果是引用类型。

### 头文件保护符

利用`#ifndef`, `#define`, `#endif`, `#ifdef`这几个预处理变量，避免头文件被多次重复包含。头文件即使（目前还）没有被包含到其他文件中，也应该设置保护符，习惯性加上即可，不必在意是否需要。

## 第三章：字符串，vector，数组

> + 头文件不应包含using声明，因为头文件的内容会拷贝到所有引用它的文件中，可能产生名字冲突。
> + c++内置类型如数组的实现与硬件密切相关，灵活性稍显不足。

### string

1.直接初始化和拷贝初始化:`string s = "abc";`为拷贝初始化, 拷贝初始化的三种形式`s = str;`, `s = string("abc");`, `s = "abc";`。
2.字符串读取：`getline(cin, line);`

### vector

1.vector能容纳绝大多数对象作为元素，但由于引用不是对象，不存在包含引用的vector。同样，数组的元素也是对象，所以不存在引用的数组。
2.初始化：

+ `vector<int> nums(10);`nums有十个元素，每个为零， `vector<int> nums{10};`nums有一个元素。
+ vector<string> v("hi"); //报错
+ vector<string> v{"hi"}; //列表初始化
+ vector<string> v{10}; //十个元素
+ vector<string> v{10, "hi"}; // 十个hi

3.通过下标访问不存在的元素的行为非常常见，而且会产生非常严重的后果。所谓的**缓冲区溢出**指的就是这类错误。大多数常见的错误都是源于缓存区溢出。
4.end()为“尾后”迭代器。

### 数组

1.因为编译时编译器必须知道数组的大小，所以数组的维度必须是**常量表达式**。如果不指定数组的维度，那么数组大小由显示初始化的维度决定。
2.字符数组末尾有一个空字符`\0`。
3.不能直接用一个数组来初始化另一个数组，也不能将一个数组拷贝给另一个数组。（编译器扩展可能会会支持，但不是标准。）
4.对于复杂数组的声明，如果没有括号，则按照从右到左理解（默认情况下，**类型修饰符从右到左依次绑定**）。如果有括号，则按照**从内到外**理解，如下：

```c++
  int *ptrs[10]; // ptrs是一个含有十个整数指针的数组
  int &refs[10]; // 错误：不存在引用的数组
  int (*parray) [10]; //parray指向一个含有十个整数的数组
  int (&RefArray) [10]; // RefArray引用一个含有十个整数的数组
  
  int a[10] = {1,2,3};
  cout << a << endl;
  cout << &a << endl;
  auto b(a);
  cout << b[1] << endl;
  decltype(a) c = {1,2,3};
  int (*d) [10] = &a;
  cout << *d << endl;
  cout << (*d)[1] << endl; //输出a[1]
  cout << d << endl; //输出a
  cout << d[0] << endl; //输出a
  cout << d[1] << endl; //输出&a[1]
  int *a1 = &a[1];
  cout << a1 << endl;
  cout << a1[1] << endl;
  cout << a1[-1] << endl; //下标竟然可以是负数
  a = a1; //报错，不能给数组赋值
  b = a1; //b为指针
  c = a1; //报错，不能给数组赋值
```

5.c++11标准提供了begin()和end()函数，返回数组的头指针和尾后指针，定义在iterator头文件中。

```c++
  int nums[] = {1,2,3};
  int *beg = begin(nums);
  int *last = end(nums);
```

6.内置类型的下标运算符所用的索引值不是无符号类型，这和vector，string不一样。
7.不要在c++中使用c风格字符串，极易引起程序漏洞，是诸多安全问题的根本原因。

##　第四章：表达式

> + 重载运算符，其包括运算变量的类型和返回值的类型，都是有该运算符决定的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的。
> + 简单归纳：当一个对象被用作右值的时候，用的是对象的纸（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。
> + 求余运算符的对象必须是整数，否则报错。`21 % -5； //结果为1`
> + 除非必须，否则不使用递增递减运算符的后置版本。一是更符合编程初衷，二是性能。`*iter++;`等价于`*(iter++)`。
> + `sizeof`运算符返回表达式或者类型所占的字节数。

###　求值顺序

1.有四种运算符明确规定了运算对象的求值顺序，为`&&`，`||`，`?:`, `,`四种。
2.**对于没有指定执行顺序的运算符来说，如果表达式指向并修改同一个对象，将会引发错误并产生未定义的行为。**
3.`int i = f1() * f2();`，其中`f1`，`f2`一定在乘法之前调用，但两个函数的执行顺序是不确定的。
4.`int i = 0; cout << i << " " << ++i << endl; //未定义`，编译器可能先求`i`再求`++i`，也可能先求`++i`再求`i`，甚至有其他完全不同的操作。因为此表达式的行为不可预知，所以不论编译器生成什么的代码程序都是错误的。其他例子，如`*iter = toupper(*iter++); //错误，未定义行为`。
5.`*++iter`合法，先执行递增再解引用。

###　运算符

1.sizeof运算符

###　类型转换

1.大多数用到数组的表达式中，数组自动转换成数组首元素的指针；当数组作为decltype关键字的参数，或者作为**取地址符**，sizeof及typeid等运算符的运算对象时，上述转换不会发生。
2.虽然有时候不得不使用强制类型转换，但这种方法本质上是非常危险的。

+ static_cast<type>()任何具有明确定义的类型，只要不包含底层const，都可以使用。类型损失的警告信息会被关闭。
+ const_cast只能改变运算对象的底层const。
+ reinterpret_cast通常为运算对象的位模式提供较底层的重新解释。使用这种转换是非常危险的，本质上依赖于机器，要想安全使用必须对涉及的类型和编译器实现转换的过程非常了解。
+ 建议：避免使用强制类型转换。

3.旧式的强制类型转换，如果转换为const_cast和static_cast也合法，则其行为与对应的命名转换一致。如果替换后不合法，则旧式强制类型转换执行与reinterpret_cast类似的功能。一旦转换过程出现问题，追踪更加困难。
`type(expr); //函数形式`
`(type)expr; //c语言风格`

## 第五章：语句（控制流）

> + 逗号表示空语句，使用空语句应该加上注释，从而使读者注意到有意的忽略。
> + 在异常发生期间正常执行“清理”工作的程序被称为异常安全的代码。当异常发生时只是简单终止程序，这样也不用担心异常安全的问题，但要保证处理异常并继续执行，就必须注意。

### switch

1.从匹配的第一条语句往后执行到最后，因此break语句非常重要。
2.建议在最后一个case和default标签后面写case，保持风格一致，避免添加新的case漏掉。

## 第六章：函数

> + 通过**调用运算符**执行函数，调用运算符是一对括号，作用于一个表达式（函数或者指向函数的指针），调用表达式的返回类型就是函数的返回类型。主调函数，被调函数。
> + 尽管实参与形参存在对应关系，但是并没有规定实参的求值顺序，编译器能以任意可行的顺序对实参求值。
> + 局部静态对象：在函数中定义static对象，在第一次经过时定义初始化，直到程序结束才销毁。
> + 参数赋值是从左到右，所有默认实参必须在右边，让那些经常使用默认值的形参出现在后面。
> + 内联可以避免函数调用的开销；一般来说，内联机制用于优化规模小、流程直接、频繁调用的函数。
> + constexpr函数，规定：函数的返回类型和参数类型都是字面值，函数体内有且只有一条return语句，隐式指定为内联。
> + constexpr函数不一定返回常量表达式，把内联和constexpr函数放在头文件中。

### 参数传递

1.值传递：指针形参，熟悉c的程序员经常使用指针类型的形参访问函数外部的对象，在c++中，**建议使用引用类型的形参代替指针**。
2.拷贝大的类类型或者容器对象比较低效，甚至有的类类型（包括io在内）根本不支持拷贝操作。当某种类型不支持拷贝时，只能通过引用形参访问。
3.如果函数无需修改引用形参的值，最好将其声明为**常量引用**。
4.使用引用形参返回额外信息（好像我经常这么做，但java不支持）。
5.用实参初始话形参时会**忽略底层const**，所以也不能利用顶层const实现重载。
6.形参的初始化方式和变量的初始化形式一样，**可以使用非常量初始化一个底层const对象，但是反过来不行**。底层const出现在指针和引用中。

```c++
  int i = 42;
  const int *cp = &i;  //correct
  int *p = cp;  //wrong
  const int &r = i;  //correct
  int &r2 = r; //wrong
```

7.尽量使用常量引用，把函数不会改变的形参定义为普通引用是一种比较常见的错误，一是误导调用者函数可以改变形参的值，二是限制函数所接受的实参类型。
8.数组形参：数组有两个特殊的性质，一是不能拷贝，所以无法以值传递的方式使用数组形参；二是数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是数组的指针，函数并不知道数组的长度。管理数组形参有三种常用技术：

+ 使用数组本身带有结束标记来指定长度，如c风格字符串。
+ 使用标准库规范，传递数组首指针和尾后指针。
+ 显示传递一个表示数组大小的形参
+ 另外：可以使用数组引用形参

```c++
  void print(const int*);  //以下三者等价
  void print(const int[]);
  void print(const int[10]); //这里的维度是我们期望的维度，实际不一定

  void print(const char *cp);
  void print(const int *begin, const int *end);
  void print(const int ia[], size_t size);
  vodi print(const (&arr)[10]);
```

### 可变参数

1.如果所有实参类型相同，c++11提供`initializer_list`，initializer_list对象的元素永远是常量；
2.如果实参类型不同，c++11提供可变参数模板；
3.省略符是一种特殊的形参类型，可以传递可变参数的形参，但一般只用于与c函数交互的借口。

### 返回类型

1.不要返回局部变量的引用和指针；
2.调用一个返回引用的函数得到的是左值，其他返回类型得到的是右值。
3.列表初始化返回值。
4.返回数组指针

```c++
  Type (*function(parameter_list)) [dimension] //返回数组指针的函数形式,数组维度是必须的。
  auto func(int i) -> int(*)[10]； //在本应返回的地方写auto,通过尾置返回类型。
  //或者使用decltype声明返回类型
```

### 函数重载

1.一个拥有**顶层const**的形参无法和另一个没有顶层const的形参区别开来，不能重载；如果形参是某种类型的指针或引用，**底层const**可以实现重载。
2.**什么时候使用重载？？？**
3.const_cast在重载函数的情景最有用。

```c++
  const string& shorterString（const string &s1, const string &s2) {
    return s1.size() < s2.size() ? s1 : s2;
  }
  string& shorterString(string &s1, string $s2) {
    auto &r = shorterString(const_cast<const string&>(s1), const_cast<const string&>(s2));
    // auto会忽略引用
    return const_cast<string&>(r);
  }
```

4.重载匹配

+ 编译器找到最佳匹配，并生成调用该函数的代码；
+ 无匹配，报错；
+ 多个匹配但不存在最佳匹配，报错；

###　函数指针

```c++
  bool lengthCompare(const string&, const string&);
  //该函数的类型是：bool(const string&, const string&);
  bool (*pf)(const string&, const string&);

  pf = lengthCompare; //二者等价，类似数组指针
  pf = &lengthcompare;

  bool b1 = lengthCompare(s1, s2); //以下为等价调用
  bool b2 = pf(s1, s2);
  bool b3 = (*pf)(s1, s2);

  //Func和Func2是函数类型
  typedef bool Func(const string&, const string&);
  typedef decltype(lengthCompare) Func2;
  //FuncP和FuncP2是函数指针类型
  typedef bool(*FuncP)(const string&, const string&);
  typedef decltype(lengthCompare) *FunctionP2;
```

## 第七章：类

> + 类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现分离的编程技术。类的接口包括用户所能执行的操作；类的实现包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。封装实现了类的接口和实现的分离。
> + 抽象，是指从众多的事务中抽取出具有共同的、本质性的特征作为一个整体。是共同特质的集合形式。封装，是将通过抽象所得到的数据信息和操作进行结合，使其形成一个有机的整体。对内执行操作，对外隐藏细节和数据信息。两者的区别，在于抽象是一种思维方式，而封装则是一种基于抽象性的操作方法。我们通过抽象所得到数据信息及其功能，以封装的技术将其重新聚合，形成一个新的聚合体，也就是类。或者说，两者是合作者的关系，如果没有抽象，封装就无从谈起，如果没有封装，抽象也将没有意义。
> + 编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体。因此，成员函数体可以随意使用类中的其他成员而无需在意他们的出现次序。
> + 可以将类的声明和定义分离开来（前向声明，此时类是不完全类型）。在创建类的对象之前，类必须定义，否则无法计算内存。

### const成员函数

1.默认情况下，this的类型是**指向类类型非常量版本的常量指针**。例如在Sales_data成员函数中，this的类型是Sales_data *const。默认情况下我们不能把this绑定到一个常量对象上，这使得我们不能在一个常量对象上调用普通的成员函数。
2.c++允许把const关键字放在成员函数的参数列表之后，表示this是一个指向常量的指针，这样的成员函数称为常量成员函数。
3.常量对象，以及常量对象的引用或者指针都只能调用常量成员函数。

### 类的定义

1.在类的外部定义成员函数时，定义必须和声明匹配。
2.定义类相关的**非成员函数**，一些**辅助函数**尽管定义的操作从概念上是属于类的接口的组成部分，但实际不属于类。应当将他们的声明和类的声明放在同一个头文件，这样用户只需引入一个头文件就可以使用接口。

```c++
  //定义一个返回this对象的函数
  Sales_data& Sales_data::combine(const Sales_data &rhs) {
    units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    return *this;
  }
```

### 构造函数

1.只有当类没有任何构造函数的情况下，编译器才会自动生成默认构造函数，又称为**合成的默认构造函数**。
2.某些类**不能依赖**合成的默认构造函数，必须定义自己的默认构造函数，有三个原因。

+ 一旦我们定义了一些其他的构造函数，除非我们再定义一个默认的构造函数，否则将没有默认构造函数。这条规则的依据是，如果一个类在某种情况下需要控制对象初始化，那么该类很可能在所有情况下都需要控制。
+ 对于某些类来说，合成的默认构造函数可能执行错误的操作。如在块中的内置类型或复合类型被默认初始化时，它们的值未定义。如果类包含内置类型或者复合类型的成员，则**只有当这些成员全都被赋予类内初始值时，这个类才适合使用合成的默认构造函数。**
+ 有时候编译器不能为某些类合成默认的构造函数。

3.通过在参数列表后面使用`=default`来要求编译器生成构造函数。
4.类内初始值，构造函数初始值列表，在类的外部定义构造函数。**初始值列表->类内初始值->默认初始化**
5.拷贝、赋值和析构，如果不自主定义，则**编译器会合成默认版本**。一般来说，编译器生成的版本将对每个成员执行拷贝，赋值和销毁操作。**某些类不能依赖于合成的版本**。
6.构造函数的初始值有时必不可少，例如当成员是const或者引用时，必须通过初始值列表初始化。
7.**在很多类中**，初始化和赋值关系到底层效率。
8.成员的初始化顺序与它们**在类定义中的出现顺序一致**，与初始值列表的顺序无关。建议二者顺序一致。
9.c++11标准添加**委托构造函数**。
10.如果构造函数只接受**一个实参**，则它实际定义了转换为此类类型的**隐式转换机制**。隐式转换机制只允许**一步类类型转换**，这种隐式转换可以通过添加`explicit`限制。所以explicit关键字只对单个参数有效。当然explicit无法限制显式转换。

### 访问控制

1.使用class和struct定义类唯一的区别就是默认的访问权限。
2.如果类想把一个函数作为它的友员，只需在类内添加一条以`friend`关键字开始的函数声明。
3.类内声明友员仅仅指定访问权限，还必须在类外再专门对函数进行声明。为了是友员对类的用户可见，通常把友员的声明（类外）和类的声明放在同一个头文件。
4.可以通过`mutable`关键字修改类常量的某些可变数据成员。

###　友员

1.如果类想把一个函数作为它的友员，只需在类内添加一条以`friend`关键字开始的函数声明。
2.类之间的友员关系
3.另成员函数作为友员：此时必须注意类之间的声明的定义顺序。
4.友员同意遵守：必须先声明在使用。

### 静态成员

1.静态函数只能访问静态成员，非静态函数既能访问非静态成员，也能访问静态成员。
2.对于类成员来说，static关键字只出现在类内部的**声明语句**。
3.一般来说，不能在类的内部初始化静态成员，相反必须在类的**外部定义和初始化每个静态成员**，一旦定义就存在程序的整个声明周期。**static constexpr 可以类内初始化**。
4.要想确保对象只定义一次，最好的方法是将静态数据成员的定义和其他非内联函数的定义放在同一个文件。
5.关于**static const**??? **constexpr**???