# notes

## 第二章

###　类型系统

> + 一般float和double分别是7，16个有效位。  
> + 类型char实际上会表现为signed char还是unsigned char，由编译器决定。  
> + c++的设计原则之一是尽可能接近硬件。。。  
> + 避免无法预知和依赖于实现环境的行为。
> + 运算符运算之前会先将运算参数转换为同样的类型。
> + 指定字面值的类型。
> + 对象是具有某种数据类型的内存空间。
> + constexpr变量？？？

[类型选择](../rsc/类型选择.png)  
[不同类型系统的语言](https://www.zhihu.com/question/19918532)  
[常用语言的类型系统分类](../rsc/类型.png)  
[不同类型系统的可移植问题](https://blog.csdn.net/u014659656/article/details/46779381)  
[c++类型转换](https://blog.csdn.net/zdplife/article/details/50922456)  
[c++类型转换](https://segmentfault.com/a/1190000016582440)  

###　类型占用内存

[int占几个字节？](https://blog.csdn.net/u014492609/article/details/38067599)  
[CPU与操作系统约束](https://blog.csdn.net/championhengyi/article/details/80458060)  
[vs为什么没有64位版本](https://www.zhihu.com/question/20370633)  
[数据模型](https://www.cnblogs.com/lsgxeva/p/7614856.html)

###　变量

1.默认初始化
(1)内置类型如果在函数体外,默认初始化为0; 如果在函数体内,则不被初始化,（严格来说，编译器并未被要求检查此类错误，大多数编译器会对部分使用未初始化变量的行为给出警告，使用未初始化的变量会带来不可预估的结果）。
(2)每个类各自决定其初始化的方式。
(3)连续赋值：赋值号是从右到左的，（赋值返回引用？？），(x=y)=3。

2.列表初始化

3.声明和定义
c++支持分离式编译，允许将一个程序拆分为多个文件分别单独编译，为了支持分离编译，c++将声明和定义区别。声明使得名字为程序所知，一个文件如何想使用别处定义的名字，就必须包含对这个名字的声明。而定义负责创建与名字关联的实体。`extern int i;//声明i而非定义i`，`int j;//声明并定义j`，`external dooble pi = 3.14;//定义`。可以多次声明，只能一次定义。

### 复合类型（指针和引用）

类型修饰符（*&）不过是**声明符**的一部分罢了，而非基本类型的一部分。**基本类型+类型修饰符+变量名**
引用必须初始化，无法重新绑定到新的对象。
使用未初始化的指针会引起的运行错误，`void*`能做的比较有限：和别的指针比较，作为函数的输入输出(**制作模板**)，或者赋值给另一个void指针。

### const

```c++
  int i = 0;
  int *const p1 = &i;  //顶层const, 不能修改p1
  const int ci = 42;  //顶层const，不能修改ci
  const int *p2 = &ci;  //底层const，允许修改p2
  const int *const p3 = p2;
  const int &r = ci;  //用于声明引用的const都是底层const
```

### 类型处理

1.通过`typedef`或`using =`进行别名声明，使得复杂的类型名称简单化。
2.auto类型声明符能让编辑器替我们分析表达式的类型，但推断出来的类型和初始值类型并不完全相同，auto会忽略顶层的const，留下底层的const；也可能去掉引用。。。
3.decltype类型指示符，作用是选择并返回操作数的数据类型，编译器分析表达式并得到类型，但**不会执行表达式或函数**。
如果表达式是**解引用**或者**有双层括号**，则结果是引用类型。

### 头文件保护符

利用`#ifndef`, `#define`, `#endif`, `#ifdef`这几个预处理变量，避免头文件被多次重复包含。头文件即使（目前还）没有被包含到其他文件中，也应该设置保护符，习惯性加上即可，不必在意是否需要。

## 第三章

> + 头文件不应包含using声明，因为头文件的内容会拷贝到所有引用它的文件中，可能产生名字冲突。
> + c++内置类型如数组的实现与硬件密切相关，灵活性稍显不足。

### string

1.直接初始化和拷贝初始化:`string s = "abc";`为拷贝初始化。
2.
